### 第2講 資料の例題

#' @exercise ベクトルの生成

(x <- c("Alice","Bob","Cathy","David"))          # 文字列のベクトル
(y <- c(1,-2, 3,-4, 5))                          # 数値のベクトル
(z <- c("apple","berry","cat","dog","elephant")) # 文字列のベクトル
#' 外側の () は代入した結果の表示．print() と同義

a <- 8; b <- 15    # 変数 a,b に値を代入．複数コマンドは ; で区切る
a:b                # a < b の場合は1ずつ増加する系列が作成される
a <- 29.5; b <- 24
a:b                # 逆の場合は1ずつ減少する系列が作成される
29.5:24            # 直接数値を書いてもよい

a <- 1; b <- 16; c <- 2 # 変数 a,b,c に値を代入
seq(a, b, by = c)       # 明示する場合は seq(from = a, to = b, by = c)

#' @exercise ベクトルの操作

length(x) # 最後の要素を参照する場合などに利用できる

x[3]        # xの第3要素 (ベクトルの添え字は1から始まる)
y[c(1,3,4)] # 複数の要素 = c(y[1], y[3], y[4])

rev(x)

c(x, z) # 同じデータ型のものは単純に結合される
c(x, y) # 異なるデータ型のものは結合できないので自動的に書き換えられる

rep(y, 3)               # 長さは length(y) * 3
rep(y, times = 3)       # 単純に繰り返す．上記と同様
rep(y, each = 3)        # 各要素を繰り返す
rep(y, length.out = 12) # 繰り返した結果の長さを指定する

#' @exercise 行列の生成

a <- 2; m <- 3; n <- 4 # 変数 a,m,n に値を代入
matrix(a, m, n)        # 明示する場合は matrix(data = a, nrow = m, ncol = n)

a <- 2:13              # 変数 a に値を代入 (m*n = 12 文字用意)
(A <- matrix(a, m, n)) # 並び順を変えるには matrix(a,m,n,byrow = TRUE)

as.vector(A) # matrix の逆変換にあたる

a <- 4:7; b <- 10:7; c <- c(2,4,8,16) # 変数 a,b,c に値を代入
rbind(a, b, c) # 行ベクトルとして結合 (row vector bind)
cbind(a, b, c) # 列ベクトルとして結合 (column vector bind)

#' @exercise 行列の操作

dim(A)    # 関数の返値は長さ2のベクトル (行数,列数) となることに注意
nrow(A)   # 行数
ncol(A)   # 列数
dim(A)[1] # nrow(A) と同値
dim(A)[2] # ncol(A) と同値

A[3,4]        # (3,4)成分
A[3, ]        # 第3行のベクトル
A[ ,4]        # 第4列のベクトル
A[c(1,3),]    # 1,3行からなる部分行列．2x4型行列になる
A[c(1,3),2:4] # 1,3行と，2,3,4列からなる部分行列．2x3型行列になる

#' @exercise リストの生成と操作

(L <- list(x,y)) # x,yを要素とするリスト

L[[1]] # リストの第1要素

#' 方法1 (作成時に名前を付与)
(L1 <- list(first=x, second=y))

#' 方法2 (作成後に名前を変更)
L2 <- list(x,y) 
names(L2) <- c("1st","2nd")
L2 # リストを表示

#' 方法1 (リストの名前で参照)
L1[["first"]]
L2[["2nd"]]

#' 方法2 (記号$を用いる場合は""は不要なことに注意)
L1$first      
L2$`2nd` # 数字で始まる文字列は``を用いる必要がある

#' 前回の練習問題
library(tibble)
(foo <-
   tibble(
     name = c("Alice", "Bob", "Carol", "Dave", "Eve"),
     math = c(90, 80, 70, 60, 50),
     phys = c(25, 50, 75,100, 80),
     chem = c(65,100, 70, 40, 75),
     bio  = c(70, 50, 30, 80,100)))

#' @exercise ベクトルの計算
#' 以下の計算例に用いるベクトルを定義する
(a <- 1:6)
(b <- c(2,3,5,7,11,13))

a + b # 同じ長さのベクトル a,b の和．同じ長さのベクトルが返る
a - b # ベクトルの差

a * b # ベクトルの成分ごとの積．同じ長さのベクトルが返る
a / b # 成分ごとの商も計算可

a %*% b # ベクトルの内積．1x1型の行列が返る

#' @exercise 行列の計算
#' 以下の計算例に用いる行列を定義する
(A <- matrix(1:6, 3, 2))
(B <- matrix(c(2,3,5,7,11,13), 3, 2))

A + B # 同じサイズの行列の和．同じサイズの行列が返る
A - B # 行列の差

A * B # 行列の成分ごとの積．同じサイズの行列が返る
A / B # 成分ごとの商も計算可

#' Bの型を変更しておく
(B <- matrix(c(2,3,5,7,11,13), 2, 3))

A %*% B # 行列の積．n x l 型行列が返る

#' Aを正方行列にしておく
(A <- matrix(1:9, 3, 3))

det(A) # 行列式

sum(diag(A)) # 行列のトレース

#' @exercise Hamilton-Cayleyの定理の確認

#' 行列を作成 (好きに設定してよい)
(A <- matrix(1:4,2,2) - diag(rep(3,2)))
#' 左辺を計算 (丸め誤差の範囲で0になる)
A %*% A - sum(diag(A)) * A + det(A) * diag(rep(1,2))

#' @exercise ベクトルと行列の乗法

A <- matrix(1:4, 2, 2); b <- c(5,6) # 行列とベクトルを作成
A %*% b                             # 行列 x ベクトル = 列ベクトル

b %*% A                             # ベクトル x 行列 = 行ベクトル

x <- solve(A, b)

solve(A,B) # AX=B の解Xを求める
solve(A)   # 逆行列 (Bが単位行列の場合省略できる)

sin(a) # 成分ごとに計算される．sin(a)[i]=sin(a[i])
sin(A) # 成分ごとに計算される．sin(A)[i,j]=sin(A[i,j])

#' @exercise 3元連立1次方程式の解法

(A <- matrix(rnorm(9), 3, 3) + diag(rep(1, 3))) # 行列とベクトルを作成
#' rnorm(9) は正規乱数を9つ作成する(後の講義で詳しく説明)
(b <- 1:3)

(x <- solve(A, b)) # 解を計算
A %*% x            # 結果の確認(b になるはず)
