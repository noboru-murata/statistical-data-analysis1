### 第2講 サンプルコード

#' @exercise ベクトルの生成

(x <- c("Alice","Bob","Cathy","David")) # 文字列のベクトル
(y <- c(1,-2, 3,-4, 5)) # 数値のベクトル
(z <- c("apple","berry","cat","dog","elephant")) # 文字列のベクトル
#' 外側の () は代入した結果の表示．print() と同義

a <- 8; b <- 15 # 変数 a,b に値を代入．複数コマンドは ; で区切る
a:b # a < b の場合は1ずつ増加する系列が作成される
a <- 29.5; b <- 24
a:b # 逆の場合は1ずつ減少する系列が作成される
29.5:24 # 直接数値を書いてもよい

a <- 1; b <- 16; c <- 2 # 変数 a,b,c に値を代入
seq(a, b, by = c) # 明示する場合は seq(from = a, to = b, by = c)

#' @exercise ベクトルの操作

length(x) # 最後の要素を参照する場合などに利用できる

x[3] # xの第3要素 (ベクトルの添え字は1から始まる)
y[c(1,3,4)] # 複数の要素 = c(y[1], y[3], y[4])

rev(x)

c(x, z) # 同じデータ型のものは単純に結合される
c(x, y) # 異なるデータ型のものは結合できないので自動的に書き換えられる

rep(y, 3) # 長さは length(y) * 3
rep(y, times = 3) # 単純に繰り返す．上記と同様
rep(y, each = 3)  # 各要素を繰り返す
rep(y, length.out = 12)  # 繰り返した結果の長さを指定する

#' ---------------------------------------------------------------------------
#' @practice ベクトルの操作
#' 
#' 1から10までの自然数のベクトル
(foo <- 1:10)
#' 1以上30以下の奇数を昇順に並べたベクトル
(bar <- seq(from = 1, to = 30, by = 2)) # 変数名を含めた丁寧な書き方
#' すべての要素が1からなる長さ10のベクトル
(baz <- rep(1, length.out = 10)) # 関数rep_len() もある
rep(1, len = 15) # 変数名は見分けられれば短くてもOK
#' 
#' ベクトルの長さを求める
length(foo)
#' 3番目の要素を取り出す
bar[3]
#' 最後の要素を取り出す
bar[length(bar)] # tail(bar,n=1) という方法もある
#' 
#' @notes
#' 関数 rep() や関数 seq() には高速化された派生型がいくつかある
#' ---------------------------------------------------------------------------

#' @exercise 行列の生成

a <- 2; m <- 3; n <- 4 # 変数 a,m,n に値を代入
matrix(a, m, n) # 明示する場合は matrix(data = a, nrow = m, ncol = n)

a <- 2:13 # 変数 a に値を代入 (m*n = 12 文字用意)
(A <- matrix(a, m, n)) # 並び順を変えるには matrix(a,m,n,byrow = TRUE)

as.vector(A) # matrix の逆変換にあたる

a <- 4:7; b <- 10:7; c <- c(2,4,8,16) # 変数 a,b,c に値を代入
rbind(a, b, c) # 行ベクトルとして結合 (row vector bind)
cbind(a, b, c) # 列ベクトルとして結合 (column vector bind)

#' @exercise 行列の操作

dim(A) # 関数の返値は長さ2のベクトル (行数,列数) となることに注意
nrow(A) # 行数
ncol(A) # 列数
dim(A)[1] # nrow(A) と同値
dim(A)[2] # ncol(A) と同値

A[3,4] # (3,4)成分
A[3, ] # 第3行のベクトル
A[ ,4] # 第4列のベクトル
A[c(1,3),] # 1,3行からなる部分行列．2x4型行列になる
A[c(1,3),2:4] # 1,3行と，2,3,4列からなる部分行列．2x3型行列になる

#' ---------------------------------------------------------------------------
#' @practice 行列の操作
#' 行列の作成
(M <- matrix(1:6, 2, 3, byrow = TRUE))
(M2 <- rbind(1:3, 4:6)) # cbind を使って作ることもできる
#' 2行2列成分を取り出す
M[2,2]
#' 転置行列を作成する
matrix(1:6, 3, 2) # 愚直に作成し直す
t(M) # 関数t()を調べてみよう
#' 行名をつける
rownames(M) <- c("first","second")
M # print(M) と同様
#' 列名をつけることもできる
colnames(M2) <- c("alpha","beta","gamma")
M2
#' ---------------------------------------------------------------------------

#' @exercise リストの生成と操作

(L <- list(x,y)) # x,yを要素とするリスト

L[[1]] # リストの第1要素

#' 方法1 (作成時に名前を付与)
(L1 <- list(first=x, second=y))

#' 方法2 (作成後に名前を変更)
L2 <- list(x,y) 
names(L2) <- c("1st","2nd")
L2 # リストを表示

#' 方法1 (リストの名前で参照)
L1[["first"]]
L2[["2nd"]]

#' 方法2 (記号$を用いる場合は""は不要なことに注意)
L1$first      
L2$`2nd` # 数字で始まる文字列は``を用いる必要がある

#' 前回の練習問題
library(tibble)
(foo <-
   tibble(
     name = c("Alice", "Bob", "Carol", "Dave", "Eve"),
     math = c(90, 80, 70, 60, 50),
     phys = c(25, 50, 75,100, 80),
     chem = c(65,100, 70, 40, 75),
     bio  = c(70, 50, 30, 80,100)))

#' @exercise ベクトルの計算
#' 以下の計算例に用いるベクトルを定義する
(a <- 1:6)
(b <- c(2,3,5,7,11,13))

a + b # 同じ長さのベクトル a,b の和．同じ長さのベクトルが返る
a - b # ベクトルの差

a * b # ベクトルの成分ごとの積．同じ長さのベクトルが返る
a / b # 成分ごとの商も計算可

a %*% b # ベクトルの内積．1x1型の行列が返る

#' @exercise 行列の計算
#' 以下の計算例に用いる行列を定義する
(A <- matrix(1:6, 3, 2))
(B <- matrix(c(2,3,5,7,11,13), 3, 2))

A + B # 同じサイズの行列の和．同じサイズの行列が返る
A - B # 行列の差

A * B # 行列の成分ごとの積．同じサイズの行列が返る
A / B # 成分ごとの商も計算可

#' Bの型を変更しておく
(B <- matrix(c(2,3,5,7,11,13), 2, 3))

A %*% B # 行列の積．n x l 型行列が返る

#' Aを正方行列にしておく
(A <- matrix(1:9, 3, 3))

det(A) # 行列式

sum(diag(A)) # 行列のトレース

#' @exercise Hamilton-Cayleyの定理の確認

#' 行列を作成 (好きに設定してよい)
(A <- matrix(1:4,2,2) - diag(rep(3,2)))
#' 左辺を計算 (丸め誤差の範囲で0になる)
A %*% A - sum(diag(A)) * A + det(A) * diag(rep(1,2))

#' ---------------------------------------------------------------------------
#' @practice ベクトルおよび行列の計算
#' 
#' 1から10までの2乗値からなるベクトル
1:10 # 1から10までのベクトル
1:10 * 1:10 # Hadamard積を利用する
#'
#' 1から10までの和
1:10 %*% rep(1, 10) # (1,2,...,10)と(1,1,...,1)の内積
sum(1:10) # 関数sum()はベクトルの成分の合計を計算することもできる
#'
#' 九九の表
matrix(rep(1:9, 9), 9, 9) # 行ごとに1から9を並べる
matrix(rep(1:9, 9), 9, 9, byrow = TRUE) # 列ごとに1から9を並べる
matrix(rep(1:9, 9), 9, 9) * matrix(rep(1:9, 9), 9, 9, byrow = TRUE)
(M <- matrix(rep(1:9, 9), 9, 9))
M * t(M) # 行列とその転置を利用してもよい
(M9 <- matrix(1:9,9,1)) 
M9 %*% t(M9) # 9x1型行列の内積による別の方法
(V9 <- 1:9); V9 %o% V9 # 講義の範囲外の方法 (%o% はベクトルの積の一つ)
#'
#' 30度の回転行列の2乗は60度の回転行列
theta <- pi/6 # 30度のラジアン値
(R30 <- # 30度の回転行列
   matrix(c(cos(theta),-sin(theta),
            sin(theta), cos(theta)), 2, 2, byrow = TRUE))
(R60 <- # 60度の回転行列
   matrix(c(cos(2*theta),-sin(2*theta),
            sin(2*theta), cos(2*theta)), 2, 2, byrow = TRUE))
R30 %*% R30 # 30度の回転行列の2乗を表示
#' ---------------------------------------------------------------------------

#' @exercise ベクトルと行列の乗法

A <- matrix(1:4, 2, 2); b <- c(5,6) # 行列とベクトルを作成
A %*% b # 行列 x ベクトル = 列ベクトル

b %*% A # ベクトル x 行列 = 行ベクトル

x <- solve(A, b)

solve(A,B) # AX=B の解Xを求める
solve(A) # 逆行列 (Bが単位行列の場合省略できる)

sin(a) # 成分ごとに計算される．sin(a)[i]=sin(a[i])
sin(A) # 成分ごとに計算される．sin(A)[i,j]=sin(A[i,j])

#' @exercise 3元連立1次方程式の解法

(A <- matrix(rnorm(9), 3, 3) + diag(rep(1, 3))) # 行列とベクトルを作成
#' rnorm(9) は正規乱数を9つ作成する(後の講義で詳しく説明)
(b <- 1:3)

(x <- solve(A, b)) # 解を計算
A %*% x # 結果の確認(b になるはず)

#' ---------------------------------------------------------------------------
#' @practice ベクトルと行列の計算
#' 
#' 1から10までの2乗値からなるベクトル
(1:10)^2 # ^2も関数として成分ごとに計算される
#'
#' エラーになる理由を考察
A %*% b # 列ベクトル (3x1型行列)
b %*% A # 行ベクトル (1x3型行列)
A %*% b + b %*% A # 異なる次元(大きさ)の行列は足し算できない
#'
#' 回転してもベクトルの長さが変わらないことを確認
#' 回転行列とベクトルを作成 (好きに設定してよい)
theta <- 2*pi/3 # 120度のラジアン値
(R <- matrix(c(cos(theta),-sin(theta),
               sin(theta), cos(theta)), 2, 2, byrow = TRUE))
(x <- 1:2)
(y <- R %*% x) # xを回転してyを作成 (結果は行列になるので扱いに注意が必要)
#'
x %*% x # xの長さの2乗はベクトルの内積で計算できる
as.vector(y) %*% as.vector(y) # yの長さの2乗
t(y) %*% y # 行列の積として計算することもできる
sum(y*y) # 行列の要素積を計算して全ての成分の和で計算することもできる
sum(y^2) # 上記と同様の計算は各成分の2乗和として計算することもできる(xも同様)
#' ---------------------------------------------------------------------------
