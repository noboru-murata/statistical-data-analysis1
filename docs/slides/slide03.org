#+TITLE: 関数と制御構造
#+SUBTITLE: 関数の定義と分岐・繰り返し処理
#+AUTHOR: 村田 昇
#+EMAIL: noboru.murata@eb.waseda.ac.jp
#+DATE: 
# Time-stamp: <2021-04-03 13:23:17 mura>
:reveal:
#+INCLUDE: "./reveal.js/org/mycourse.org"
#+STARTUP: hidestars content
# C-c C-x C-v でinlineを切り替え
# <m C-i でlatex block (math env用)
# C-c '
:end:

* 講義の内容
  - R言語における関数
  - 引数の扱い方 (引数名・順序・既定値)
  - 自作関数の定義
  - 制御構造 (条件分岐・繰り返し)
    
  #+begin_src R :eval no :exports none :tangle yes
    ### 第03回 練習問題解答例
  #+end_src
  #+begin_src R :exports none
    setwd("~/Desktop/lectures/u-tokyo/spring/slide")
  #+end_src
  

* COMMENT メモ
  - 関数の使い方，引数の扱い，順番，既定値
    
* R言語における関数
** 関数
   - 関数の取り扱いは一般的な計算機言語とほぼ同様
   - 関数は引数とその値を指定して実行
   - ただし引数名は順序を守れば省略可能
   - [[color:darkgreen][関数の呼び出し方]]
     #+begin_src R :eval no
       f(arg1=value1, arg2=value2) 
       ## arg1, arg2 は引数の名前，value1, value2 は引数に渡す値を表す
       f(value1, value2) # 上と同値．順序に注意
     #+end_src

   # - 引数が存在しない，
   #  もしくはすべての引数に対し既定値が設定されている関数もある．
   #  例えば ~f~ がそのような関数だった場合，
   #  コンソール上で
   #  #+begin_src R :exports code
   #  f()    
   #  #+end_src
   #  を実行すると引数=既定値として関数の内容が実行される
   # - 典型例はRを終了する関数 ~q()~
** 関数の実行例
   - [[color:darkgreen][正弦関数の計算]]
     #+begin_src R :exports both :results output
       sin(x = pi/2) 
       sin(pi/2) # 上と同値
     #+end_src
   - [[color:darkgreen][対数関数の計算]] (xやbに適当な数値を代入せよ)
     #+begin_src R :eval no
       log(x, b) # 底をbとする対数
       log(x=x, base=b) #上と同値
       log(base=b, x=x) #上と同値
       log(b,x) # = log(x=b,base=x) 
       log(x) # 自然対数 =log(x,base=exp(1))
     #+end_src

** 引数
   
* 関数の定義
** 自作関数
   - 他の言語と同様にRでも関数を定義できる   
   - 関数の定義には関数 ~function()~ を利用する 
   - [[color:darkgreen][半径 r から球の体積と表面積を求める関数]]
     #+begin_src R 
       myfunc <- function(r){
           V <- (4/3) * pi * r^3 # 球の体積
           S <- 4 * pi * r^2     # 球の表面積
           out <- c(V,S) # 返り値のベクトルを作る
           names(out) <- c("volume", "area") # 返り値の要素に名前を付ける
           return(out) # 値を返す
       }
       myfunc(1) # 実行
     #+end_src

* 制御構造
** 制御文
   - 最適化や数値計算などを行うためには，
     条件分岐や繰り返しを行うための仕組みが必要となる
   - R言語を含む多くの計算機言語では
     - ~if~  (条件分岐)
     - ~for~  (繰り返し・回数指定)
     - ~while~  (繰り返し・条件指定)
   - これを *制御文* と言う 

** ~if~ 文
   - 条件Aが *真* のときプログラムXを実行する
     #+begin_src R :exports code
       if(条件A) プログラムX
     #+end_src
   - 上記の ~if~ 文に条件Aが *偽* のときプログラムYを実行することを追加する
     #+begin_src R :exports code
       if(条件A) プログラムX else プログラムY    
     #+end_src
** ~if~ 文の例
   - [[color:darkgreen][20200724が19で割り切れるか?]]
     #+begin_src R :exports none :tangle yes
       ### 例題3
       ### if文の例
     #+end_src
     #+begin_src R :tangle yes
       if(20200724 %% 19 == 0) {# %% は余りを計算
           print("割り切れます")
           print(20200724 %/% 19) # 商を表示
       } else { # {}で囲まれたブロックが1つのプログラム
           print("割り切れません")
           print(20200724 %% 19) # 余りを表示
       } 
     #+end_src
** ~for~ 文
   - ベクトル ~V~ の要素を *順に* 変数 ~i~ に代入して
     プログラムXを繰り返し実行する
     #+begin_src R :exports code
       for(i in V) プログラムX
     #+end_src
   - プログラムXは変数 ~i~ によって実行内容が変わる
** ~for~ 文の例
   - [[color:darkgreen][アルファベットの20,15,11,25,15番目を表示]]
     #+begin_src R :exports none :tangle yes
       ### 例題4
       ### for文の例
     #+end_src
     #+begin_src R :tangle yes
       print(LETTERS) # LETTERS ベクトルの内容を表示
       for(i in c(20,15,11,25,15)) {
           print(LETTERS[i]) # 順番に表示
       }
     #+end_src
** ~while~ 文
   - 条件Aが *真* である限りプログラムXを繰り返す
     #+begin_src R :exports code
       while(条件A) プログラムX
     #+end_src
   - プログラムXは実行するたびに実行内容が変わり，
     いつか条件Aが満たされなくなるように書く
   - /(~repeat~ 文というものもある)/
** ~while~ 文の例
   - [[color:darkgreen][20200809を素因数分解する]]
     #+begin_src R :exports none :tangle yes
       ### 例題5
       ### while文の例
     #+end_src
     #+begin_src R :tangle yes
       n <- 20200809 # 分解の対象
       p <- 2 # 最初に調べる数
       while(n != 1){ # 商が1になるまで計算する
           for(i in p:n){ # pからnまで順に調べる
               if(n%%i == 0) { # 余りが0か確認
                   print(i) # 割り切った数を表示
                   n <- n/i # 商を計算して分解の対象を更新
                   p <- i # 最初に調べる数を更新
                   break # for文を途中で終了
               }  
           }
       }
     #+end_src
   # ** ~repeat~ 文
   #    - プログラムXを繰り返し実行
   #      #+begin_src R :exports code
   #        repeat プログラムX
   #      #+end_src
   #    - プログラムXには
   #      #+begin_src R :exports code
   #        if(条件A) break
   #      #+end_src
   #      という記述が含まれている必要がある．
   #      この記述は，「条件Aが成立したら繰り返しをやめる」という意味

* 演習
  :PROPERTIES:
  :reveal_background: #fef4f4
  :END:
** 例題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 三角形の3辺の長さ $x,y,z$ を与えると
     面積 $S$ を計算する関数を作成せよ．
   - 参考: *ヘロンの公式* より
     # #+begin_export latex
     \begin{equation}
       S=\sqrt{s(s-x)(s-y)(s-z)},\qquad
       s=\frac{x+y+z}{2}
     \end{equation}
     # #+end_export
     が成り立つ．
** 解答例
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   #+begin_src R :exports none :tangle yes
     ### 例題6
     ### 三角形の面積を計算する関数
   #+end_src
   #+begin_src R :exports both :results output :tangle yes
     area <- function(x,y,z){
         s <- (x+y+z)/2
         S <- (s*(s-x)*(s-y)*(s-z))^(1/2)
         ## S <- sqrt(s*(s-x)*(s-y)*(s-z)) # 平方根を求める関数を用いても良い
       return(S)
     }
     area(3,4,5) # 直角三角形で検算
     area(12,13,5)
   #+end_src
** 演習
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 非負の整数 $n$ の階乗 $n!$ を求める関数を作成せよ．
     #+begin_src R :exports none :tangle yes
       ### 練習3.1
       ### 階乗を計算する関数
       ## for文を用いた関数
       fact1 <- function(n){
           val <- 1
           for(i in 1:n){
               val <- val*i
           }
           return(val)
       }
       fact1(0) # 間違い
       fact1(1)
       fact1(2)
       fact1(3)
       fact1(4)
       ## if文を用いた修正版
       fact2 <- function(n){
           if(n==0){
               return(1)
           } else {
               val <- 1
               for(i in 1:n){
                   val <- val*i
               }
               return(val)
           }
       }
       fact2(0) # 正しい
       fact2(1)
       fact2(2)
       fact2(3)
       fact2(4)
       ## while文を用いた関数
       fact3 <- function(n){
           val <- 1
           while(n>0){
               val <- val*n
               n <- n-1
           }
           return(val)
       }
       fact3(0)
       fact3(1)
       fact3(2)
       fact3(3)
       fact3(4)
     #+end_src
   - 整数 $n$ の Fibonacci数を求める関数を作成せよ．
     # #+begin_export latex
     \begin{align}
       F_{0}&=0\\
       F_{1}&=1\\
       F_{n}&=F_{n-1}+F_{n-2}
     \end{align}
     # #+end_export
     #+begin_src R :exports none :tangle yes
       ### 練習3.2
       ### Fibonacci数を返す関数
       fibo <- function(n){
           f0 <- 0 # 第0項の設定
           f1 <- 1 # 第1項の設定
           if(n<0) {
               print("計算できません")
               return(NA) # 欠損値を返す
           }
           if(n==0) { # n=0の場合
               return(f0)
           }
           if(n==1) { # n=1の場合
               return(f1)
           }
           for(i in 2:n) { # n>=2の場合
               fn <- f1 + f0 # fn = fn-1 + fn-2 の計算
               f0 <- f1 # fn-2 の値の更新
               f1 <- fn # fn-1 の値の更新
           }
           return(fn) # 計算結果を返す
       }
     #+end_src
   - 行列 $X$ が与えられたとき，各列の平均を計算する関数を作成せよ．
     #+begin_src R :exports none :tangle yes
       ### 練習3.3
       ### 行列の列の平均を計算する関数
       colave <- function(X) {
           ave <- rep(0,length=ncol(X)) # 平均を記録するベクトルを用意
           for(i in 1:ncol(X)){ # 列ごとに計算
               ave[i] <- sum(X[,i])/nrow(X) # 平均の定義に従って計算
               ## ave[i] <- mean(X[,i]) # 平均を計算する関数を用いても良い
           }
           return(ave)
       }
       (A <- matrix(1:12,3,4,byrow=TRUE))
       colave(A)
     #+end_src
   - 前問で $X$ がベクトルの場合にはその平均を計算するように修正せよ．\\
     /(関数 ~is.vector()~ が利用できる)/
     #+begin_src R :exports none :tangle yes
       ### 練習3.4
       ### ベクトルと行列を扱えるように修正
       colave <- function(X){ 
           if(is.vector(X)){
               ave <- mean(X)
           } else {
               ave <- rep(0,length=ncol(X))
               for(i in 1:ncol(X)){
                   ave[i] <- mean(X[,i])
               }
           }
           return(ave)
       }
       (A <- matrix(1:12,3,4,byrow=TRUE))
       colave(A)
       (x <- 1:12)
       colave(x)
     #+end_src



* COMMENT ローカル変数
# Local Variables:
# org-latex-listings: minted
# End:
   
