#+TITLE: 関数と制御構造
#+SUBTITLE: 関数の定義とプログラムの作成
#+AUTHOR: 村田 昇
#+EMAIL: noboru.murata@eb.waseda.ac.jp
#+DATE: 
# Time-stamp: <2021-04-16 16:10:53 mura>
:reveal:
#+INCLUDE: "./reveal.js/org/mycourse.org"
#+STARTUP: hidestars content
# C-c C-x C-v でinlineを切り替え
# <m C-i でlatex block (math env用)
# C-c '
:end:

* 講義の内容
  - R言語における関数
  - 引数の扱い方 (引数名・順序・既定値)
  - 自作関数の定義
  - 制御構造 (条件分岐・繰り返し)
    
  #+begin_src R :eval no :exports none :tangle yes
    ### 第03回 練習問題解答例
  #+end_src
  #+begin_src R :exports none
    setwd("~/Desktop/lectures/u-tokyo/spring/slide")
  #+end_src
  

* COMMENT メモ
  - 関数の使い方，引数の扱い，順番，既定値
    

* R言語における関数
** 関数
   - 関数の取り扱いは一般的な計算機言語とほぼ同様
   - 関数は引数とその値を指定して実行 \\
     /[[color:gray][引数がない場合もある]]/
   - 引数名は順序を守れば省略可能
   - [[color:darkgreen][関数の呼び出し方]]
     #+begin_src R :eval no
       f(arg1=value1, arg2=value2) 
       ## arg1, arg2 は引数の名前，value1, value2 は引数に渡す値を表す
       f(value1, value2) # 上と同値．順序に注意
     #+end_src

** 関数の実行例
   - [[color:darkgreen][正弦関数の計算]]
     #+begin_src R :exports both :results output
       sin(x = pi/2) 
       sin(pi/2) # 上と同値 (引数と値の関係が明かなら引数名は省略可能)
     #+end_src
   - [[color:darkgreen][対数関数の計算]] 
     #+begin_src R :eval no
       x <- 16; b <- 2 # xやbに適当な数値を代入する
       log(x=x, base=b) # 底をbとする対数
       log(x, b) # 上と同値
       log(base=b, x=x) # 上と同値
       log(b,x) # 上と異なる (=log(x=b,base=x))
       log(x) # 自然対数 (既定値による計算 =log(x,base=exp(1)))
     #+end_src

** 引数
   - ヘルプにより関数の引数および返値を確認できる
     - 引数については "Arguments" の項を参照
     - 返値については "Values" の項を参照
   - 引数を省略すると既定値 (default) が用いられる
   - [[color:darkgreen][ヘルプによる関数仕様の表示]]
     #+begin_src R :eval no
       ## 正規乱数を生成する関数
       help(rnorm) # Help Pane から指定しても良い
       ## ヒストグラムを表示する関数
       ?hist
     #+end_src

** 既定値を持つ関数の実行例 (1/2)
   - [[color:darkgreen][正規乱数の生成]] 
     #+begin_src R
       rnorm(7) # 平均0 分散1 の正規乱数を7個生成
       rnorm(7, mean=10) # 平均10 分散1 の正規乱数を7個生成
       rnorm(sd=0.1, n=7) # 平均0 分散0.01 の正規乱数を7個生成
       rnorm(n=7, mean=2, sd=2) # 平均2 分散4 の正規乱数を7個生成
     #+end_src

** 既定値を持つ関数の実行例 (2/2)
   - [[color:darkgreen][ヒストグラムの表示]] 
     #+begin_src R
       foo <- rnorm(n=10000, mean=50, sd=10) # 平均50 標準偏差10 の正規乱数
       hist(foo) # データ以外全て既定値で表示
       hist(foo, # 既定値のいくつかを変更する
            breaks=30, # ビンを30程度に調整する
            col="lightgreen", # 色の指定
            main="mathematics", # タイトルの指定
            xlab="score") # x軸ラベルの指定
       ## Plots Pane に着目
     #+end_src


* 演習
  :PROPERTIES:
  :reveal_background: #fef4f4
  :END:
** COMMENT 練習問題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   -何かの関数を調べさせる
   計算させる
   2つくらい組み合わせて計算してもらう
   

* 関数の定義
** 自作関数
   - 他の言語と同様にRでも関数を定義できる   
   - 関数の定義には関数 ~function()~ を利用する 
     functionの記法を書く
     #+begin_src R :eval no
       関数名 <- function(引数){ # 計算ブロックの開始
           ## このブロック内に必要な手続きを記述する．複数行に渡って構わない
           return(返値) # 計算結果を明示的に示す
       } # ブロックの終了
     #+end_src

** 自作関数の例
   - [[color:darkgreen][半径 r から球の体積と表面積を求める関数]]
     #+begin_src R 
       foo <- function(r){
           V <- (4/3) * pi * r^3 # 球の体積
           S <- 4 * pi * r^2     # 球の表面積
           out <- c(V,S) # 返り値のベクトルを作る
           names(out) <- c("volume", "area") # 返り値の要素に名前を付ける
           return(out) # 値を返す
       }
       foo(2) # 実行
     #+end_src
** 自作関数の例
   - [[color:darkgreen][初項 a 公比 r の等比数列の最初のn項 (既定値は5)]]
     #+begin_src R 
       bar <- function(a, r, n=5){
           out <- a*r^(1:n-1)
           return(out) # 値を返す
       }
       bar(1,2) # 初項1 公比2 の最初の5項
       bar(1,2,10) # 初項1 公比2 の最初の10項
       bar(n=10,1,2) # 変数名を指定して位置を変えることができる
       bar(r=0.5,n=10,a=512) # 同上
     #+end_src


* 演習
  :PROPERTIES:
  :reveal_background: #fef4f4
  :END:
** 例題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 三角形の3辺の長さ $x,y,z$ を与えると
     面積 $S$ を計算する関数を作成せよ．
     - 参考: *ヘロンの公式* より
       #+begin_src latex
         \begin{equation}
           S=\sqrt{s(s-x)(s-y)(s-z)},\quad
           s=\frac{x+y+z}{2}
         \end{equation}
       #+end_src
       が成り立つ．

** 解答例
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   #+begin_src R :exports none :tangle yes
     ### 例題 三角形の面積を計算する関数
   #+end_src
   #+begin_src R :exports both :results output :tangle yes
     myHeron <- function(x,y,z){
         s <- (x+y+z)/2 # 補助変数 s の計算
         S <- sqrt(s*(s-x)*(s-y)*(s-z)) # ヘロンの公式による面積の計算
         return(S)
     }
     myHeron(3,4,5) # よく知られた直角三角形を使って計算結果を確認する
     myHeron(12,13,5) 
   #+end_src

** 練習問題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 1から整数 $n$までの和を求める関数を作成せよ．
     - 関数 ~sum()~ を調べてみよ (help(sum))
     - 等差数列の和を利用してもよい
   - 整数 $n$ の階乗 $n!$ を求める関数を作成せよ．
     - 関数 ~prod()~ を調べてみよ (help(prod))

   #+begin_src R :exports none :tangle yes
     ### 練習問題
     ## 和を計算する関数
     mySum <- function(n){
         out <- sum(1:n) # 1からnまでの整数を生成して和を求める
         return(out)
     }
     mySum(10) # 1から10までの和は?
     ## 別解
     mySum <- function(n){
         out <- n*(n+1)/2 # 等差数列の和を利用した場合
         return(out)
     }

     ## 階乗を計算する関数
     myFact <- function(n){
         out <- prod(1:n) # 1からnまでの整数を生成して積を求める
         return(out)
     }
     myFact(5) # 5! は?
   #+end_src
	  
* 制御構造
** 制御文
   - 最適化や数値計算などを行うためには，
     条件分岐や繰り返しを行うための仕組みが必要となる
   - R言語を含む多くの計算機言語では
     - ~if~  (条件分岐)
     - ~for~  (繰り返し・回数指定)
     - ~while~  (繰り返し・条件指定)
   - これを *制御文* と言う 

** ~if~ 文
   - 条件Aが *真* のときプログラムXを実行する
     #+begin_src R :exports code
       if(条件A) プログラムX
     #+end_src
   - 上記の ~if~ 文に条件Aが *偽* のときプログラムYを実行することを追加する
     #+begin_src R :exports code
       if(条件A) プログラムX else プログラムY    
     #+end_src

** ~if~ 文の例
   - [[color:darkgreen][20210423が19で割り切れるか?]]
     #+begin_src R :exports none :tangle yes
       ### 例題 if文の例
     #+end_src
     #+begin_src R :tangle yes
       if(20210423 %% 19 == 0) {# %% は余りを計算
           print("割り切れます") 
           print(20200724 %/% 19) # 商を表示
       } else { # {}で囲まれたブロックが1つのプログラム
           print("割り切れません")
           print(20210423 %% 19) # 余りを表示
       } 
     #+end_src

** ~for~ 文
   - ベクトル ~V~ の要素を *順に* 変数 ~i~ に代入して
     プログラムXを繰り返し実行する
     #+begin_src R :exports code
       for(i in V) プログラムX
     #+end_src
   - プログラムXは変数 ~i~ によって実行内容が変わる
** ~for~ 文の例
   - [[color:darkgreen][アルファベットの20,15,11,25,15番目を表示]]
     #+begin_src R :exports none :tangle yes
       ### 例題 for文の例
     #+end_src
     #+begin_src R :tangle yes
       print(LETTERS) # LETTERS ベクトルの内容を表示
       for(i in c(20,15,11,25,15)) {
           print(LETTERS[i]) # 順番に表示
       }
     #+end_src

** ~while~ 文
   - 条件Aが *真* である限りプログラムXを繰り返す
     #+begin_src R :exports code
       while(条件A) プログラムX
     #+end_src
   - プログラムXは実行するたびに実行内容が変わり，
     いつか条件Aが満たされなくなるように書く
   - /(~repeat~ 文というものもある)/
** ~while~ 文の例
   - [[color:darkgreen][20200809を素因数分解する]]
     #+begin_src R :exports none :tangle yes
       ### 例題 while文の例
     #+end_src
     #+begin_src R :tangle yes
       n <- 20200809 # 分解の対象
       p <- 2 # 最初に調べる数
       while(n != 1){ # 商が1になるまで計算する
           for(i in p:n){ # pからnまで順に調べる
               if(n%%i == 0) { # 余りが0か確認
                   print(i) # 割り切った数を表示
                   n <- n/i # 商を計算して分解の対象を更新
                   p <- i # 最初に調べる数を更新
                   break # for文を途中で終了
               }  
           }
       }
     #+end_src
   # ** ~repeat~ 文
   #    - プログラムXを繰り返し実行
   #      #+begin_src R :exports code
   #        repeat プログラムX
   #      #+end_src
   #    - プログラムXには
   #      #+begin_src R :exports code
   #        if(条件A) break
   #      #+end_src
   #      という記述が含まれている必要がある．
   #      この記述は，「条件Aが成立したら繰り返しをやめる」という意味


* 演習
  :PROPERTIES:
  :reveal_background: #fef4f4
  :END:
** 例題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 制御構造を利用して非負の整数 $n$ の階乗 $n!$ を求める関数を作成せよ．
     - 関数 ~prod()~ を用いないこと

** 解答例
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - ~for~ 文を用いた例

   #+begin_src R :eval no :exports none :tangle yes
     ### 例題 nの階乗を求める関数 (for文)
   #+end_src
   #+begin_src R :exports both :results output :tangle yes
     myFact1 <- function(n){
         val <- 1 # 初期値の代入
         for(i in 1:n){ # 1からnまで順に掛ける
             val <- val*i
         }
         return(val) # 計算結果を返す
     }
     myFact1(0) # 間違い (0!=1)
     myFact1(1) # 正しい
     myFact1(2) # 正しい
     myFact1(3) # 正しい
     myFact1(4) # 正しい
   #+end_src

   #+reveal: split
   - if文を用いた修正版

   #+begin_src R :exports both :results output :tangle yes
     myFact2 <- function(n){
         if(n==0){ # n=0 か確認して分岐する
             return(1)
         } else {
             val <- 1
             for(i in 1:n){
                 val <- val*i
             }
             return(val)
         }
     }
     myFact2(0) # 正しい
     myFact2(1) # 正しい
     myFact2(2) # 正しい
     myFact2(3) # 正しい
     myFact2(4) # 正しい
   #+end_src
   
   #+reveal: split
   - while文を用いた例

   #+begin_src R :exports both :results output :tangle yes
     myFact3 <- function(n){
         val <- 1 # 初期値の代入
         while(n>0){ # nから1まで順に掛ける．nが0なら計算しない
             val <- val*n
             n <- n-1
         }
         return(val)
     }
     myFact3(0) # 正しい
     myFact3(1) # 正しい
     myFact3(2) # 正しい
     myFact3(3) # 正しい
     myFact3(4) # 正しい
   #+end_src

** 練習問題
   :PROPERTIES:
   :reveal_background: #fef4f4
   :END:
   - 整数 $n$ の Fibonacci数を求める関数を作成せよ．
     # #+begin_export latex
     \begin{align}
       F_{0}&=0\\
       F_{1}&=1\\
       F_{n}&=F_{n-1}+F_{n-2}
     \end{align}
     # #+end_export

     #+begin_src R :exports none :tangle yes
       ### 練習3.2
       ### Fibonacci数を返す関数
       fibo <- function(n){
           f0 <- 0 # 第0項の設定
           f1 <- 1 # 第1項の設定
           if(n<0) {
               print("計算できません")
               return(NA) # 欠損値を返す
           }
           if(n==0) { # n=0の場合
               return(f0)
           }
           if(n==1) { # n=1の場合
               return(f1)
           }
           for(i in 2:n) { # n>=2の場合
               fn <- f1 + f0 # fn = fn-1 + fn-2 の計算
               f0 <- f1 # fn-2 の値の更新
               f1 <- fn # fn-1 の値の更新
           }
           return(fn) # 計算結果を返す
       }
     #+end_src
   - 行列 $X$ が与えられたとき，各列の平均を計算する関数を作成せよ．
     #+begin_src R :exports none :tangle yes
       ### 練習3.3
       ### 行列の列の平均を計算する関数
       colave <- function(X) {
           ave <- rep(0,length=ncol(X)) # 平均を記録するベクトルを用意
           for(i in 1:ncol(X)){ # 列ごとに計算
               ave[i] <- sum(X[,i])/nrow(X) # 平均の定義に従って計算
               ## ave[i] <- mean(X[,i]) # 平均を計算する関数を用いても良い
           }
           return(ave)
       }
       (A <- matrix(1:12,3,4,byrow=TRUE))
       colave(A)
     #+end_src
   - 前問で $X$ がベクトルの場合にはその平均を計算するように修正せよ．\\
     /[[color:gray][関数 ~is.vector()~ が利用できる]]/
     #+begin_src R :exports none :tangle yes
       ### 練習3.4
       ### ベクトルと行列を扱えるように修正
       colave <- function(X){ 
           if(is.vector(X)){
               ave <- mean(X)
           } else {
               ave <- rep(0,length=ncol(X))
               for(i in 1:ncol(X)){
                   ave[i] <- mean(X[,i])
               }
           }
           return(ave)
       }
       (A <- matrix(1:12,3,4,byrow=TRUE))
       colave(A)
       (x <- 1:12)
       colave(x)
     #+end_src

* COMMENT ローカル変数
# Local Variables:
# org-latex-listings: minted
# End:
   
